# A builder is looking to build a row of N houses that can be of K different colors. 
# He has a goal of minimizing cost while ensuring that no two neighboring houses are of the same color.
# Given an N by K matrix where the nth row and kth column represents the cost to build the nth house with kth color, 
# return the minimum cost which achieves this goal.

### First Method O(2^N * K) runtime
# for each house we either choose the current first best cost, or the current second best cost. 
# E.g. in the below setting the optimal solution is to use the color with the second-best cost:
# a = [
#      [2, 3, 6, 1],
#      [4, 6, 8, 2],
#      [3, 4, 3, 5],
#      [2, 4, 5, 3]
#     ]
# We recursively try both approaches, then choosing the better one

def min_cost(array):

  def _min_cost(array, last_color_index=None):
    if len(array) == 0:
      return 0
    
    first_best_cost, second_best_cost = float('inf'), float('inf')
    first_best_cost_index, second_best_cost_index = None, None
    for index, item in enumerate(array[0]):
      if index != last_color_index:
        if item < first_best_cost:
          first_best_cost, second_best_cost = item, first_best_cost
          first_best_cost_index, second_best_cost_index = index, first_best_cost_index
        elif item < second_best_cost:
          second_best_cost = item
          second_best_cost_index = index
    
    return min( first_best_cost + _min_cost(array[1:], first_best_cost_index)
              , second_best_cost + _min_cost(array[1:], second_best_cost_index)
              ) 

  return _min_cost(array)

### Second Method O(NK) time, O(K) extra space
# The crutial observation is that when we choose the first or second-best item for the first row,
# in the next rows we don't need to do this again. It is enough to continue in a greedy fashion in both paths 
# generated by the two options for the first row. The reason is that, for example in the second row the both options 
# are going to be covered if we continue in a greedy fashion starting from the two paths from the first row.

def min_cost(array):

  # finding the best two colors for first house
  first_best = min(array[0])
  first_best_index = array[0].index(first_best)
  c = array[0][:]
  c[first_best_index] = float('inf')
  second_best = min(c)
  second_best_index = c.index(second_best)

  total_cost_1, total_cost_2 = first_best, second_best

  # continue in a greedy fashion using the first-best cost for the first row
  prev_best_cost_index, cur_best_cost_index = first_best_index, None
  for row in array[1:]:
    best_color_cost = float('inf')
    for index, item in enumerate(row):
      if item < best_color_cost and index != prev_best_cost_index:
        best_color_cost = item
        cur_best_cost_index = index
    prev_best_cost_index = cur_best_cost_index
    total_cost_1 += best_color_cost
  
  # continue in a greedy fashion using the second-best cost for the first row
  prev_best_cost_index, cur_best_cost_index = second_best_index, None
  for row in array[1:]:
    best_color_cost = float('inf')
    for index, item in enumerate(row):
      if item < best_color_cost and index != prev_best_cost_index:
        best_color_cost = item
        cur_best_cost_index = index
    prev_best_cost_index = cur_best_cost_index
    total_cost_2 += best_color_cost

  return min(total_cost_1, total_cost_2)


a = [
  [2, 3, 6, 1],
  [4, 6, 8, 2],
  [2, 3, 4, 6],
  [10, 2, 1, 4]
]

print(min_cost(a))
